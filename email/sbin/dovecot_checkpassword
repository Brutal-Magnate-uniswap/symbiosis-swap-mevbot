#!/usr/bin/perl -w

=head1 NAME

dovecot_checkpassword -- Password checking script for dovecot

=cut

=head1 DESCRIPTION

This script is used in checking passwords using the checkpwd interface
developed for qmail against the values set for users of the Bytemark Symbiosis
system.

=cut

=head1 USAGE

dovecot_checkpassword [ prog ]

=cut

=head1 OPTIONS

   --help        Show the help information for this script.
   --manual      Read the manual for this script.

=cut

=head1 USAGE

This script reads a username, terminated by NULL, followed by a password
terminated by NULL from file descriptor 3.  It then checks the result against
the value in /srv/domain/mailboxes/localpart/password.  The result of this
comparison is then returned as an exit status.

The password file can plain text or use any hash supported by crypt(3).

On successful completion, this program executes the program given as an
argument, and sets the Dovecot environment variables.

=cut

=head1 EXAMPLES
 
To test the interface, use the following command

 echo -e -n "test@example.com\0a very secret password\0" | dovecot_checkpassword 3<&0 ; echo $?

where "test@example.com" is the username and "a very secret password" is the
password.  The exit status determines the result of the lookup.

=cut

=head1 EXIT STATUS

This script returns 0 for success, 1 for permanent failure, and 111 for
temporary failure. 

=cut

=head1 SEE ALSO

dovecot(1), http://cr.yp.to/checkpwd/interface.html, http://wiki.dovecot.org/PasswordDatabase/CheckPassword

=cut

=head1 AUTHOR

Patrick J. Cherry <patrick@bytemark.co.uk>

=cut

#

use strict;
use User::pwent;
use File::stat;
use Sys::Syslog;
use Getopt::Long;
use Pod::Usage;


my $HELP   = 0;
my $MANUAL = 0;


#  Parse options.
#
if ( !GetOptions( "help", \$HELP, "manual", \$MANUAL ) )
{
    exit;
}

pod2usage(1) if $HELP;
pod2usage( -verbose => 2, -noperldoc => 1 ) if $MANUAL;


my $VHOST_DIR         = "srv";
my $VHOST_MAILBOX_DIR = "mailboxes";
my $VHOST_CONFIG_DIR  = "config";

# These are error codes suitable for dovecot.
my $TEMPORARY_ERROR = 111;
my $PERMANENT_ERROR = 1;

sub cleanup
{
    my ($error_code) = (@_);

    sleep 5 if ( $error_code gt 0 );

    exit($error_code);
}


#Dovecot also sets some environment variables that the script may use:
#
# * SERVICE: contains eg. imap, pop3 or smtp
# * TCPLOCALIP and TCPREMOTEIP: Client socket's IP addresses if available
# * MASTER_USER: If master login is attempted. This means that the password
#   contains the master user's password and the normal username contains the
#   user who master wants to log in as.

my $ip      = "unknown ip";
my $service = "unknown";
# Used for userdb lookups
my $authorized = "0";

$ip         = $ENV{ 'TCPREMOTEIP' } if defined $ENV{ 'TCPREMOTEIP' };
$service    = $ENV{ 'SERVICE' }     if defined $ENV{ 'SERVICE' };
$authorized = $ENV{ 'AUTHORIZED' }  if defined $ENV{ 'AUTHORIZED'};

my ( $length, $buffer );

# Open syslog
openlog( "dovecot_checkpassword", "ndelay", "mail" );

# Read from file descriptor 3
if ( open( FD, "<&=3" ) )
{
    $length = read( FD, $buffer, 512 );
    close FD;

}
else
{
    syslog(
        'err',
        'Failed to open descriptor 3 to read during login from %s for %s service',
        $ip,
        $service
    );

    cleanup($TEMPORARY_ERROR);
}

if ( $length < 4 )
{
    syslog( 'err', 'Received bad data!' );

    cleanup($TEMPORARY_ERROR);
}

my ( $username, $password, $timestamp, $rest ) = split( /\0/, $buffer );

my ( $local_part, $domain );

if ( $username =~ /^(([a-z0-9_\-]+\.?)+)@(([a-z0-9\-]+\.?)+)$/ )
{
    $local_part = $1;
    $domain     = $3;

}
else
{
    syslog( 'err', 'Bad username "%s" from %s for %s service',
            $username, $ip, $service );

    sleep 5;
    cleanup($PERMANENT_ERROR);
}

my $local_part_dir = "/$VHOST_DIR/$domain/$VHOST_MAILBOX_DIR/$local_part";
my $pwfile         = "$local_part_dir/password";
my $real_password;

#
# Use the AUTHORIZED env variable for userdb lookups, as per http://wiki1.dovecot.org/AuthDatabase/CheckPassword
#
if ( $authorized eq "1" ) {
    $ENV{"AUTHORIZED"} = 2;

    syslog(
        'debug',
        'userdb look-up for %s',
        $username
    );

} else {

    # Read the password file
    if ( open( PWFILE, $pwfile ) )
    {
        $real_password = <PWFILE>;
        close(PWFILE);

    }
    else
    {
        syslog( 'err',
                'Unable to open file %s for username %s from %s for %s service',
                $pwfile, $username, $ip, $service );

        cleanup($PERMANENT_ERROR);
    }

    # Make sure we have a real_password set, and chomp it if we do.
    if ($real_password)
    {
        chomp $real_password;
    }
    else
    {
        syslog(
            'err',
            'Empty/non-existent password set for username %s from %s for %s service',
            $username,
            $ip,
            $service
        );

        cleanup($PERMANENT_ERROR);
    }

    # Make sure we have a password set
    if ( not $password )
    {
        syslog( 'err', 'Bad password for username %s from %s for %s service',
                $username, $ip, $service );

        cleanup($PERMANENT_ERROR);
    }

    # Check the password, crypt first, plaintext second.
    if (
         not( $real_password =~ /^({CRYPT})?((\$1\$)?.*)$/i and
              $2 and
              $2 ne "" and
              crypt( $password, $2 ) eq $2 ) and
         not( $real_password ne "" and $password eq $real_password ) )
    {
        syslog( 'err', 'Bad password for username %s from %s for %s service',
                $username, $ip, $service );

        cleanup($PERMANENT_ERROR);
    }
} 

# The user is the owner of the $local_part_dir
my $user;
my $uid_stat;
if ( ( $uid_stat = stat($local_part_dir) ) )
{
    $user = getpwuid( $uid_stat->uid );

}
else
{
    syslog( 'err', 'Unable to stat %s for username %s from %s for %s service',
            $local_part_dir, $username, $ip, $service );

    cleanup($TEMPORARY_ERROR);
}

#
# Per-user/domain quota.
#
my $quota = "0";
my $user_quota_file   = "$local_part_dir/mailbox_quota";
my $domain_quota_file = "/$VHOST_DIR/$domain/$VHOST_CONFIG_DIR/mailbox_quota";

if ( open( QUOTAFILE, $user_quota_file ) or open( QUOTAFILE, $domain_quota_file ) )
{  
    $quota = <QUOTAFILE>;
    chomp $quota;
    close(QUOTAFILE);
}

##
# OK at the point we are supposed to do the following:
#
#  * Set user's home directory to $HOME environment. This isn't required, but highly encouraged.
#  * Set $USER environment variable. If the user name was changed (eg. if you lowercased "Username" to "username"), you can tell about it to Dovecot by setting $USER to the changed user name.
#  * Change the process's effective UID and GID to the user's UNIX UID and GID.
#  * Alternatively you could set userdb_uid and userdb_gid environments and add them to EXTRA environment 
#  * Your program received a path to checkpassword-reply binary as the first parameter. Execute it. 
#
# We do not change the effective UID/GID.  We set the userdb_uid/gid instead.
#
my %dovecot_extras = ( 
  'userdb_user' => $username,
  'userdb_home' => $local_part_dir,
  'userdb_uid' =>  $user->uid,
  'userdb_gid' =>  $user->gid,
  'userdb_mail' => "maildir:$local_part_dir/Maildir",
  'userdb_quota_rule' => "*:bytes=$quota"
);

$ENV{ 'USER' } = $username;
$ENV{ 'HOME' } = $local_part_dir;

#
# Set the extras up.
#
$ENV{ 'EXTRA' } = join(" ",keys ( %dovecot_extras ));
#
# Merge in the envirnonemt
#
%ENV = (%ENV, %dovecot_extras);

#
# Execute the checkpassword-reply script.
#
if ( defined @ARGV ) {
  exec(@ARGV);
}

#
# OK all done.
#
exit(0);

