#!/usr/bin/ruby
# NAME
#  symbiosis-check-mailbox-password -- Check a password for a mailbox 
#
# SYNOPSIS
#  symbiosis-check-mailbox-password [ -h | --help ] [-m | --manual]
#
# OPTIONS
#  -h, --help            Show a help message, and exit.
#
#  -m, --manual          Show this manual, and exit.
#
# USAGE
#
# This script is used in checking passwords using the checkpwd interface
# developed for qmail against the values set for users of the Bytemark
# Symbiosis system.
# 
# This script reads a username, terminated by NULL, followed by a password
# terminated by NULL from file descriptor 3. It then checks the result against
# the value in /srv/domain/mailboxes/localpart/password. The result of this
# comparison is then returned as an exit status.
# 
# The password file can plain text or use any hash supported by crypt(3).
# 
# On successful completion, this program executes the program given as an
# argument, and sets the Dovecot environment variables.
# 
# EXAMPLES
# 
# To test the interface, use the following command
# 
#  echo -e -n "test@example.com\0a very secret password\0" | symbiosis_checkpassword 3<&0 ; echo $?
# 
# where "test@example.com" is the username and "a very secret password" is the
# password. The exit status determines the result of the lookup.
# 
# EXIT STATUS
# 
# This script returns 0 for success, 1 for permanent failure, and 111 for
# temporary failure. 
# 
# SEE ALSO
# 
# dovecot(1), http://cr.yp.to/checkpwd/interface.html, http://wiki.dovecot.org/PasswordDatabase/CheckPassword
# 
# AUTHOR
# 
# Patrick J. Cherry <patrick@bytemark.co.uk>
# 

require 'getoptlong'
require 'syslog'

# These are error codes suitable for dovecot.  
TEMPORARY_ERROR = 111
PERMANENT_ERROR = 1
SUCCESS         = 0

manual = help = false
opts = GetoptLong.new(
         [ '--help',       '-h', GetoptLong::NO_ARGUMENT ],
         [ '--manual',     '-m', GetoptLong::NO_ARGUMENT ]
       )

opts.each do |opt,arg|
  case opt
  when '--help'
    help = true
  when '--manual'
    manual = true
  end
end

#
# CAUTION! Here be quality kode.
#
if manual or help
  # Open the file, stripping the shebang line
  lines = File.open(__FILE__){|fh| fh.readlines}[1..-1]

  found_synopsis = false

  lines.each do |line|

    line.chomp!
    break if line.empty?

    if help and !found_synopsis
      found_synopsis = (line =~ /^#\s+SYNOPSIS\s*$/)
      next
    end

    puts line[2..-1].to_s

    break if help and found_synopsis and line =~ /^#\s*$/

  end

  exit 0
end

#
# Require these bits here, so we can generate the manpage without needing extra
# build-deps.
#
require 'symbiosis/domains'
require 'symbiosis/domain/mailbox'

ip       = "unknown"
service  = "unknown"
username = nil
password = nil
authorized = nil

ip       = ENV['TCPREMOTEIP' ] if ENV.has_key?('TCPREMOTEIP')
service  = ENV[ 'SERVICE' ]    if ENV.has_key?( 'SERVICE' )
# Used for userdb lookups
authorized = ENV[ 'AUTHORIZED' ]  if ENV.has_key?( 'AUTHORIZED' )

# Open syslog
syslog = Syslog.open( File.basename($0), Syslog::LOG_NDELAY && Syslog::LOG_PERROR, Syslog::LOG_MAIL)

begin
  data = nil

  IO.open(3,"r") do |io|
    data = io.read(512)
  end

  if data.length < 4
    syslog.info "Received bad data during login from #{ip} for #{service} service"
    exit TEMPORARY_ERROR
  end

  username, password, timestamp, rest = data.split( "\0" )

  #
  # username sanity check
  #
  if username.nil? 
    syslog.info "No username given from #{ip} for #{service} service"
    syslog.err  "#{service} login failure from IP: #{ip} username: nil"
  
    exit PERMANENT_ERROR
  end

  mailbox = Symbiosis::Domains.find_mailbox(username)

  if mailbox.nil?
    syslog.info "Non-existent mailbox #{username.inspect} from #{ip} for #{service} service"
    syslog.err  "#{service} login failure from IP: #{ip} username: #{username.inspect}"

    exit PERMANENT_ERROR
  end

  #
  # Try logging in.
  #
  unless authorized or mailbox.login(password.to_s)
    syslog.info "Bad password for username #{username.inspect} from #{ip} for #{ftp} service"
    syslog.err  "#{service} login failure from IP: #{ip} username: #{username.inspect}"

    exit PERMANENT_ERROR
  end

rescue => err

  #
  # Rescue all exceptions, to make sure authentication doesn't happen
  # automatically when things fail
  #
  syslog.err "#{err} for username #{username} from #{ip} for #{service} service"
  syslog.debug err.backtrace.join("\n")
  exit TEMPORARY_ERROR
end

# 
# If we get this far, we're authorised. 
#

#
# OK at the point we are supposed to do the following:
#
#  * Set user's home directory to $HOME environment. This isn't required, but highly encouraged.
#  * Set $USER environment variable. If the user name was changed (eg. if you lowercased "Username" to "username"), you can tell about it to Dovecot by setting $USER to the changed user name.
#  * Change the process's effective UID and GID to the user's UNIX UID and GID.
#  * Alternatively you could set userdb_uid and userdb_gid environments and add them to EXTRA environment 
#  * Your program received a path to checkpassword-reply binary as the first parameter. Execute it. 
#
# We do not change the effective UID/GID.  We set the userdb_uid/gid instead.
#
dovecot_extras = {
  'userdb_user' => username,
  'userdb_home' => mailbox.directory,
  'userdb_uid' =>  mailbox.domain.uid,
  'userdb_gid' =>  mailbox.domain.gid,
  'userdb_mail' => "maildir:#{mailbox.directory}/Maildir",
}

unless mailbox.quota.nil? or 0 == mailbox.quota
  dovecot_extras['userdb_quota_rule'] = "*:bytes=#{mailbox.quota}"
end

ENV[ 'USER' ] = mailbox.username
ENV[ 'HOME' ] = mailbox.directory

#
# Set the extras by adding the keys to the EXTRA variable.
#
ENV[ 'EXTRA' ] = dovecot_extras.keys.join(" ") 

#
# Merge in the envirnonemt
#
dovecot_extras.each do |k,v|
  ENV[k] = v.to_s
end

#
# Execute the checkpassword-reply script.
#
exec *ARGV if ( ARGV.length > 0 )

#
# OK all done.
#
exit SUCCESS

