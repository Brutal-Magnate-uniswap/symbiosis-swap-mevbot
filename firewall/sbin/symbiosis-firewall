#!/usr/bin/ruby
# NAME
#  symbiosis-firewall -- Symbioisis firewall management
#
# SYNOPSIS
#  symbiosis-firewall [ -h | --help ] [-m | --manual] [ -v | --verbose ]
#       [ -p | --prefix <dir> ] [ -t | --template-d <dir> ] 
#       [ -x | --no-exec] [ -d | --no-delete ] <action>
#
# OPTIONS
#  -h, --help            Show a help message, and exit.
#
#  -m, --manual          Show this manual, and exit.
#
#  -v, --verbose         Show verbose errors
#
#  -p, --prefix <dir>    Directory where action.d, incoming.d, outgoing.d etc
#                        are located. Defaults to /etc/symbiosis/firewall.
#
#  -t, --template-d <dir>  Additional directory to search for templates.
#
#  -x, --no-exec         Do not execute the generated firewall rules
#
#  -d, --no-delete       Do not delete the generated script
#
#  <action>              The action to run. This defaults to "load".
#
# USAGE
#
# This firewall script is designed to be simple to use, while still allowing a
# reasonable level of control over your system. This command is used to update
# the iptables(8) and ip6tables(8) firewalls. It uses a set of directories in
# the prefix directory to define which rules should be applied.
# 
# The script will be executed once it has been generated, and then removed.
# (You may use --no-delete and --no-execute to prevent either action from being
# carried out.)
#
# Usage of the Symbiosis firewall is comprehensively documented in the
# symbiosis-documentation package, as well as on the documentation website.
#
# If this script is run as a user other than root, then the --no-execute and
# --no-delete flags are set.
#
# CONFIGURATION
#
# To configure the firewall which is generated and applied to your server you
# simply need to create files in the directories the script reads:
#
# $PREFIX/incoming.d/   This directory is examined to determine which rules
#                       should be applied to incoming connections.
#
# $PREFIX/outgoing.d/   This directory is examined to determine which rules
#                       should be applied to outgoing connections.
#
# $PREFIX/blacklist.d/  Any file present in this directory is assumed to be the
#                       IP address of a machine you wish to globally prevent
#                       connections from.
#
# $PREFIX/whitelist.d/  Any file present in this directory is assumed to be the
#                       IP address of a machine you wish to globally allow connections from.
#
# $PREFIX/local.d/      Executable shell-scripts in this directory are executed
#                       after the firewall is installed.
#
# For the incoming and outgoing directories you should create files with names
# such as "10-ssh". (The prefix you choose merely determines sorting order.)
#
# The presence of a file named "NN-ssh" will mean that the firewall will
# include rules it knows about for the service "ssh". These rule types may be
# arbitrarily complex, as they are processed via bash(1).
#
# The presence of a rule file will allow access to the named service. For
# example the file "10-ssh" placed in the incoming directory will allow all
# access to port 22. If you wish to restrict access place the hostnames, or IP
# addresses, in the file instead of leaving it empty. This will restrict
# access to/from the named addresses.
#
# ACTIONS AND TEMPLATES
#
# The "actions" are bash(1) scripts, that have been templated using eRuby.
# Each action is found in the action.d directory located inside the prefix
# directory.
#
# The actions that this program comes with are
# 
#   load              Load the firewall.
#   flush             Flush the firewall.
#   reload-blacklist  Update the blacklist chain.
#   reload-whitelist  Update the whitelist chain.
# 
# It is possible to add your own actions to the template as needed.
#
# ADDING ADDITIONAL RULETYPES
#
# For each "rule" type you should simply create two files:
#
#   /usr/local/share/symbiosis/firewall/rule.d/$name.incoming
#   /usr/local/share/symbiosis/firewall/rule.d/$name.outgoing
#
# The contents of these file(s) will be inserted appropriately into the
# generated firewall script.
#
# The magic strings '$SRC' and '$DEST' will be replaced by any IP addresses the
# user has specified in their file - or removed if none are present.
#
# SEE ALSO
#  symbiosis-firewall-whitelist(1), symbiosis-firewall-blacklist(1),
#  iptables(8), ip6tables(8)
#
# AUTHOR
#  Steve Kemp <steve@bytemark.co.uk>
#  Patrick J Cherry <patrick@bytemark.co.uk>
#


require 'getoptlong'
require 'tempfile'
require 'fileutils'
require 'symbiosis/firewall/directory'
require 'symbiosis/firewall/template'

def verbose(s)
  puts s if $VERBOSE
end


#
##
##  Entry point.
##
#######
##############

#
#  Parse the arguments
#
help     = false
manual   = false
$VERBOSE = false
execute  = delete = (Process.uid == 0)
base_dir     = '/etc/symbiosis/firewall'
template_dir = '/usr/share/symbiosis/firewall/rule.d'

opts = GetoptLong.new(
         [ '--help',       '-h', GetoptLong::NO_ARGUMENT ],
         [ '--manual',     '-m', GetoptLong::NO_ARGUMENT ],
         [ '--verbose',    '-v', GetoptLong::NO_ARGUMENT ],
         [ '--no-execute', '-x', GetoptLong::NO_ARGUMENT ],
         [ '--no-delete',  '-d', GetoptLong::NO_ARGUMENT ],
         [ '--prefix',     '-p', GetoptLong::REQUIRED_ARGUMENT ],
         [ '--template-d', '-t', GetoptLong::REQUIRED_ARGUMENT ]
       )

opts.each do |opt,arg|
  case opt
  when '--help'
    help = true
  when '--manual'
    manual = true
  when '--verbose'
    $VERBOSE = true
   when '--test'
    test = true
  when '--no-execute'
    execute = false
  when '--no-delete'
    delete = false
  when '--prefix'
    base_dir     = File.expand_path(arg)
  when '--template-d'
    template_dir = File.expand_path(arg)
  end
end

#
# CAUTION! Here be quality kode.
#
if manual or help
  # Open the file, stripping the shebang line
  lines = File.open(__FILE__){|fh| fh.readlines}[1..-1]

  found_synopsis = false

  lines.each do |line|

    line.chomp!
    break if line.empty?

    if help and !found_synopsis
      found_synopsis = (line =~ /^#\s+SYNOPSIS\s*$/)
      next
    end

    puts line[2..-1].to_s

    break if help and found_synopsis and line =~ /^#\s*$/

  end

  exit 0
end

#
# Exit if we've been disabled
#
if File.exists?(File.join(base_dir, "disabled"))
  puts "Firewall disabled.  Exiting." if $VERBOSE
  exit 0 
end

#
# Set the action
#
action = ARGV.first || "load"

# DONE parseCommandLineArguments
# TODO sanityCheck
# DONE flushAllRules
# DONE createTemporaryFile
# DONE processWhitelist
# TODO processHostsAllow -- and hosts.deny, I suppose..
# DONE processBlacklist
# DONE findRules
# TODO findDevices -- is this needed?
# DONE processRule
# DONE processRuleTemplate
# DONE addRule
# TODO testFirewall
# DONE loadKernelModules
# DONE fixOwnership
# DONE parseServices


begin
  include Symbiosis::Firewall

  #
  # Change the ownership of the firewall directory, if we're going to execute
  # the firewall script
  #
  FileUtils.chown_R("admin", "admin", base_dir) if execute 

  #
  # Load the ports from /etc/services
  #
  Ports.load

  #
  # Set up the template directories.
  #
  Template.directories = %w(/usr/local/share/firewall/rule.d /usr/local/share/symbiosis/firewall/rule.d /usr/share/firewall/rule.d /usr/share/symbiosis/firewall/rule.d)
  Template.directories = template_dir unless template_dir.nil?

  #
  # Find the script.
  #
  script_path = nil

  #
  # Search for the script in the same directores as the templates, ish.
  #
  Template.directories.collect{|d| d.sub("rule.d","action.d") }.each do |script_dir|
    script_path = File.join(script_dir, "#{action}.sh.erb")
    break if File.exists?(script_path)
  end

  #
  # Make sure we can find the script
  #
  unless ( File.exists?(script_path) )
    warn "Could not find action script for #{action.inspect}"
    exit 1
  end

  #
  # Create temp file
  #
  tf = Tempfile.new(File.basename($0)+"-")

  #
  # OK ERB it up, baby!
  #
  script = File.read(script_path)
  tf.puts ERB.new(script,0,'%').result(binding)
  tf.close

  #
  # Make the script executable.
  #
  FileUtils.chmod(0755, tf.path)

  #
  # Only execute if we're root.
  #
  if ( execute and ::Process.uid == 0 )

    unless system( tf.path )
      warn "Firewall script failed.  Flushing rules."

      #
      # FIXME: This is deliberatly hard-coded, although it probably needs to catch errors better.
      #
      %w(/sbin/iptables /sbin/ip6tables).each do |cmd|
        #
        # Check that the command exists, and we can run it.
        #
        next unless File.executable?(cmd)

        %w(INPUT FORWARD OUTPUT).each do |chain|
          #
          # Fix policy, flush chain, and allow everything on loopback.
          #
          system(cmd, "-P #{chain} ACCEPT") 
        end
        #
        # Flush everything
        #
        system(cmd,"-F")
        #
        # Delete any old chains
        #
        system(cmd,"-X")
      end

      #
      # Leave the script for inspection.
      #
      delete = false

      #
      # Further warning.
      #
      warn "This machine is now running *without* a firewall in place."
    end
  end

  unless( delete )
    #
    #  TODO: Fix this.  Because we used Tempfile we have to manually
    # copy the firewall to a new name as it is unlinked at process exit.
    #
    new_path = tf.path+"-saved"
    FileUtils.cp tf.path, new_path 
    puts "Left firewall script in #{new_path} for inspection."
  end

end

