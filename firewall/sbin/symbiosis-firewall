#!/usr/bin/ruby
#
# NAME
#   firewall -- The symbiosis firewall package.
#
# SYNOPSIS
#  General Options:
#
#  Help Options:
#
#   --help        Show the help information for this script.
#   --verbose     Show debugging information.
#
#
# DETAILS
#   This script is designed to both generate and load a simple firewall
#  based upon the contents of a hierarchy of flat files and directories.
#
#   This means that creating a firewall will be as simple as touching a file
#  or removing and existing one.
#
#
# AUTHOR
# ------
#
#    Steve Kemp <steve@bytemark.co.uk>
#


require 'getoptlong'
require 'tempfile'
require 'symbiosis/firewall/directory'
require 'symbiosis/firewall/template'

def verbose(s)
  puts s if $VERBOSE
end


#
##
##  Entry point.
##
#######
##############




#
#  Parse the arguments
#
help     = false
manual   = false
$VERBOSE = false
test     = false
flush    = false
execute  = true
delete   = true
base_dir = '/etc/symbiosis/firewall'
template_dir = '/usr/share/symbiosis/firewall/rule.d'
services = '/etc/services'

#
# This allows us just to symlink straight to /etc/network/if-up.d and if-down.d
#
if ENV.has_key?('IFACE')
  flush = true if "stop" == ENV['MODE']
  $VERBOSE = true if ENV.has_key?('VERBOSE')
end

opts = GetoptLong.new(
                      [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
                      [ '--manual', '-m', GetoptLong::NO_ARGUMENT ],
                      [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
                      [ '--test', '-t', GetoptLong::NO_ARGUMENT ],
                      [ '--flush', '-f', GetoptLong::NO_ARGUMENT ],
                      [ '--no-execute', '-x', GetoptLong::NO_ARGUMENT ],
                      [ '--no-delete', '-d', GetoptLong::NO_ARGUMENT ],
                      [ '--no-root', '-R', GetoptLong::NO_ARGUMENT ],
                      [ '--base-d', '-b', GetoptLong::REQUIRED_ARGUMENT ],
                      [ '--template-d', '-T', GetoptLong::REQUIRED_ARGUMENT ],
                      [ '--services', '-s', GetoptLong::REQUIRED_ARGUMENT ]
                     )

opts.each do |opt,arg|
  case opt
  when '--help'
    help = true
  when '--verbose'
    $VERBOSE = true
  when '--flush'
    flush = true
  when '--test'
    test = true
  when '--no-execute'
    execute = false
  when '--no-delete'
    delete = false
  when '--base-d'
    base_dir = File.expand_path(arg)
  when '--template-d'
    template_dir = File.expand_path(arg)
  when '--services'
    services = arg
  end
end

#
# Set the action
#
action = ARGV.first || "load"

if ( help )
  # Open the file, stripping the shebang line
  lines = File.open(__FILE__){|fh| fh.readlines}[2..-1]

  lines.each do |line|
    line.chomp!
    break if line.empty?
    puts line[2..-1].to_s
  end
  exit 0
end

# DONE parseCommandLineArguments
# TODO sanityCheck
# DONE flushAllRules
# DONE createTemporaryFile
# DONE processWhitelist
# TODO processHostsAllow -- and hosts.deny, I suppose..
# DONE processBlacklist
# DONE findRules
# TODO findDevices -- is this needed?
# DONE processRule
# DONE processRuleTemplate
# DONE addRule
# TODO testFirewall
# DONE loadKernelModules
# TODO fixOwnership
# DONE parseServices


begin
  include Symbiosis::Firewall

  Ports.load(services)

  #
  #  Write the firewall to a local file
  #
  Template.directories = %w(/usr/local/share/firewall/rule.d /usr/local/share/symbiosis/firewall/rule.d /usr/share/firewall/rule.d /usr/share/symbiosis/firewall/rule.d)
  Template.directories = template_dir unless template_dir.nil?

  #
  # Handy file-finder.
  #
  script_path = Template.find("#{action}.sh.erb", Template.directories.collect{|d| d.sub("rule","action")} )

  #
  # Make sure we can find the script
  #
  unless ( File.exists?(script_path) )
    warn "Could not find action script for #{action.inspect}"
    exit 1
  end

  #
  # Create temp file
  #
  tf = Tempfile.new(File.basename($0)+"-")

  #
  # OK ERB it up, baby!
  #
  script = File.read(script_path)
  tf.puts ERB.new(script,0,'%').result(binding)
  tf.close

  if ( execute )
    system( "chmod 755 #{tf.path}" )
    system( tf.path )
  end

  unless( delete )
    #
    #  TODO: Fix this.  Because we used Tempfile we have to manually
    # copy the firewall to a new name as it is unlinked at process exit.
    #
    Kernel.system("cp #{tf.path} #{tf.path}-saved")
    puts "Left firewall in #{tf.path}-saved"
  end
end


