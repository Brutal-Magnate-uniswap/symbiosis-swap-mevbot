#! /usr/bin/ruby1.8
#
# NAME
#
#   firewall-whitelist -- Automatically whitelist IP addresses.
#
# SYNOPSIS
#
#  Options:
#
#   --prefix      The directory to operate upon.
#
#  Help Options:
#
#   --help        Show the help information for this script.
#   --verbose     Show debugging information.
#
# This script is designed to automatically whitelist IP addresses which
# have been used to successfully login via SSH.
#
# It does this by parsing the output of the "last" command, and creating
# entries in /etc/symbiosis/firewall/whitelist.d/
#
# AUTHOR
#
#   Steve Kemp <steve@bytemark.co.uk>
#

#
#  Modules we require
#

require 'getoptlong'
require 'ipaddr'
require 'symbiosis/utmp'
require 'symbiosis/firewall/directory'
require 'symbiosis/firewall/template'
require 'tempfile'

opts = GetoptLong.new(
    [ '--help',    '-h', GetoptLong::NO_ARGUMENT ],
    [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
    [ '--prefix',  '-p', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--template-d', '-t', GetoptLong::REQUIRED_ARGUMENT ]
)


#
#  The options set by the command line.
#
$HELP    = false
$VERBOSE = false
$PREFIX = "/etc/symbiosis/firewall/"
delete   = false
execute  = false
template_dir = nil
force = true

opts.each do |opt,arg|
  case opt
    when '--help'
      $HELP = true
    when '--verbose'
      $VERBOSE = true
    when '--prefix'
      $PREFIX = arg
    when '--template-d'
      template_dir = arg
  end
end


#
# CAUTION! Here be quality kode.
#
if $HELP
  # Open the file, stripping the shebang line
  lines = File.open(__FILE__){|fh| fh.readlines}[2..-1]

  lines.each do |line|
    line.chomp!
    break if line.empty?
    puts line[2..-1].to_s
  end

  exit 0
end


#
#  Expire old entries first of all, then add new ones.
#
puts "Expiring old whitelist entries" if ( $VERBOSE )

expired = 0
whitelist_d = File.join($PREFIX, "whitelist.d")

# ensure the directory exists.
if ( ! File.directory?( "#{whitelist_d}" ) )
  system( "mkdir -p #{whitelist_d}" )
end

if ( File.directory?( whitelist_d ) )
  Dir.foreach( whitelist_d ) do |entry|
    if ( ( entry =~ /\.auto$/i ) &&
         (File.mtime( "#{whitelist_d}/#{entry}" ) <  ( Time.now - 8 * 24 * 60 * 60 ) ) )
    then
      puts "Removing #{whitelist_d}/#{entry}" if ( $VERBOSE )
      File.unlink("#{whitelist_d}/#{entry}")
      expired += 1
    end
  end
end
puts "Expiring done - removed #{expired} file(s)" if ( $VERBOSE )


#
# Fetch the IP addresses
#
ip_addresses = Symbiosis::Utmp.read.collect{|entry| entry["ip"]}

#
#  Did we update?
#
updated=false

#
#  Iterate over each IP
#
ip_addresses.each do |ip|
  #
  # We only want IP addresses.
  #
  next unless ip.is_a?(IPAddr)

  #
  # FIXME: Need better IPv6 conditions.
  #
  if ( ( ip.ipv4? and 
         !( IPAddr.new("127.0.0.1/8").include?(ip) or IPAddr.new("0.0.0.0") == ip )
       ) or (
         ip.ipv6? and IPAddr.new("2000::/3").include?(ip)
       ) 
     )

    puts "Found IP address: #{ip}" if ( $VERBOSE )

    if ( File.exists?( "#{whitelist_d}/#{ip}.auto" ) )
      puts "\tAlready whitelisted" if ( $VERBOSE )
    else

      # create the file
      system( "touch #{whitelist_d}/#{ip}.auto" )

      updated=true
      puts "\tAdding to whitelist" if ( $VERBOSE )
    end
  end
end



#
# Re-generate the whitelist chain
#
if ( updated || expired > 0 || force )
  system( "symbiosis-firewall reload-whitelist" )
end

