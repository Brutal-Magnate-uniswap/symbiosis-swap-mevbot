require 'symbiosis/firewall/rule'
require 'symbiosis/firewall/directory_ip_list'

#
# A meta-class which represents this firewall
#
module Symbiosis
  class Firewall

    attr_reader :incoming
    attr_reader :outgoing
    attr_reader :blacklist
    attr_reader :whitelist
    attr_reader :template
    attr_accessor :template_dir

    #
    #  Constructor
    #
    def initialize(dir="/etc/symbiosis/firewall")
      @base_dir = dir
      @template_dir = '/usr/share/symbiosis/firewall/rule.d/'
    end

    #
    # Exectute the command or die.
    #
    def xsys(cmd)
      if 0 == Process.uid
        exit $?.exitstatus unless Kernel.system(cmd)
      else
        warn "Not running #{cmd.inspect} -- not root!"
      end
    end


    #
    #  Is the firewall disabled?
    #
    def disabled?
      return File.exists?( File.join(@base_dir, "disabled" ) )
    end


    #
    # Run a self-test upon the firewall rules.  This merely needs to
    # test that an outgoing DNS lookup succeeds, and that an external
    # ping succeeds.
    #
    #  If the test fails it will call flush().
    #
    def test
      puts "'firewall --test' invoked.  TODO - Write code."
      0
    end

    #
    #  Flush/Remove all existing firewall rules.
    #
    def flush()
      flush_ipv4
      flush_ipv6
    end


    #
    #  Flush all IPv4-specific firewall rules which might be present.
    #
    def flush_ipv4
      commands = [
                 "/sbin/iptables -P INPUT ACCEPT",
                 "/sbin/iptables -P OUTPUT ACCEPT",
                 "/sbin/iptables -P FORWARD ACCEPT",
                 "/sbin/iptables -F",
                 "/sbin/iptables -t nat -F",
                 "/sbin/iptables -t raw -F",
                 "/sbin/iptables -t mangle -F",
                 "/sbin/iptables -X"
      ];

      commands.each do |cmd|
        xsys( cmd )
      end
    end


    #
    #  Flush all IPv6-specific firewall rules which might be present.
    #
    def flush_ipv6
      commands = [
                 "/sbin/ip6tables -P INPUT ACCEPT",
                 "/sbin/ip6tables -P OUTPUT ACCEPT",
                 "/sbin/ip6tables -P FORWARD ACCEPT",
                 "/sbin/ip6tables -F",
                 "/sbin/ip6tables -t nat -F",
                 "/sbin/ip6tables -t raw -F",
                 "/sbin/ip6tables -t mangle -F",
                 "/sbin/ip6tables -X"
      ];

      commands.each do |cmd|
        xsys( cmd )
      end
    end



    #
    # Is IPv6 enabled?
    #
    def ipv6?
      return(@ipv6)
    end

    #
    #  This method is the key which ties all the distinct steps together.
    #
    #  It is responsible for :
    #
    #   1.  Writing out the static prefix to the firewall.
    #
    #   2.  Writing out the whitelist and blacklist parts.
    #
    #   3.  Writing out the individual rules.
    #
    #   4.  Closing and returning the name of that file.
    #
    def create_firewall(fw)

      #
      #  Write our header there.
      #
      fw.puts <<EOF
#!/bin/bash
#
#  This firewall script was automatically generated by the
# Bytemark Symbiosis firewall package.
#
#
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11
export PATH

#
# Enable free use of loopback interfaces
#
/sbin/iptables -A INPUT  -i lo -j ACCEPT
/sbin/iptables -A OUTPUT -o lo -j ACCEPT


#
# Ditto for IPv6.
#
#
ip6tables -A INPUT  -i lo -j ACCEPT 
ip6tables -A OUTPUT -o lo -j ACCEPT 

EOF


      if File.directory?( File.join(@base_dir, "whitelist.d" ) )
        #
        #  Now write out our whitelist - which comes first.
        #
        wlist = DirectoryIPList.new( File.join(@base_dir, "whitelist.d" ) )
        fw.puts( wlist.whitelist )
      end

      if File.directory?( File.join(@base_dir, "blacklist.d" ) )
        #
        #  Now we write out our blacklist.
        #
        blist = DirectoryIPList.new( File.join(@base_dir, "blacklist.d" ) )
        fw.puts( blist.blacklist )
      end

      #
      #  Finally we have to write out our rules.
      #
      read_rules( File.join(@base_dir, "incoming.d" ) ).each do |name,addresses|
        t = Rule.new( name )
        t.template_dir = @template_dir
        t.permit()
        t.incoming()
        unless addresses.empty?
          addresses.each do |a|
            t.address = a
            fw.puts( t.to_s )
          end
        else
          fw.puts( t.to_s )
        end
      end

      read_rules( File.join(@base_dir, "outgoing.d" ) ).each do |name|

        t = Rule.new( name )
        t.template_dir = @template_dir
        t.permit()
        t.outgoing()
        unless addresses.empty?
          addresses.each do |a|
            t.address = a
            fw.puts( t.to_s )
          end
        else
          fw.puts( t.to_s )
        end
      end

      return fw
    end


    #
    # Here be dragons.
    #
    private

    #
    #  Read from an incoming/outgoing directory and collate the results.
    #
    # TODO:  Rethink this - as here we only read the names, and we should
    #        also take account of the ACL which might be inside the file.
    #
    def read_rules( directory )
      #
      # Results is an array of arrays:
      #
      #  [
      #    [port/template1, [ipaddress1, ipaddress2]],
      #    [port/template2, [ipaddress3, ipaddress4]],
      #  ]
      #
      # and so on.
      #
      results = Array.new

      return results unless File.directory?( directory )

      Dir.entries( directory ).reject{|f| f !~ /^([0-9]*)-(.*)$/}.sort.each do |entry|
        entry =~ /^([0-9]*)-(.*)$/
        template = $2
        #
        # File.readlines always returns an array, one element per line, even for dos-style files.
        #
        results << [template, File.readlines(File.join(directory,entry)).collect{|l| l.chomp}]
      end


      #
      #  Return the names.
      #
      results
    end

  end

end

