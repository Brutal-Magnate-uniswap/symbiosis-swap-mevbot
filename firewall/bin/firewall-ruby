#!/usr/bin/ruby

require 'getoptlong'
require 'singleton'


#
# This is a helper-class designed to lookup the appropriate port
# number for a given service.  It is a singleton.
#
class PortLookup
 include Singleton

  #
  #  Return the port number for the given service
  #
  def lookup( name )

    #
    #  It was already numeric?
    #
    if ( name =~ /^([0-9]+)$/ )
      return name.to_i
    end

    #
    #  Otherwise load the data from /etc/services
    #
  end
end








#
#  This class encapsulates a single firewall (iptables) rule.
#
class FirewallRule

  attr_reader :port
  attr_reader :jump
  attr_reader :direction
  attr_reader :source
  attr_reader :acl


  #
  #  Constructor
  #
  def initialize( name )
    @direction = nil
    @jump      = nil
    @src       = nil
    @port      = nil
    @acl       = nil
  end

  #
  #  Helper
  #
  def FirewallRule.blacklist( ip )
    f = FirewallRule.new( "blacklist-#{ip}" )
    f.incoming()
    f.src( ip)
    f.deny()
    return f
  end

  #
  #  Helper
  #
  def FirewallRule.whitelist( ip )
    f = FirewallRule.new( "whitelist-#{ip}" )
    f.incoming()
    f.src( ip )
    f.permit()
    return f
  end


  #
  #  Set this rule to work against incoming connections.
  #
  def incoming
    @direction = "INPUT"
  end


  #
  #  Is this incoming?
  #
  def incoming?
    return( @direction == "INPUT" )
  end


  #
  # Set this rule to work against outgoing connections.
  #
  def outgoing
    @direction = "OUTPUT"
  end


  #
  #  Is this an outgoing rule?
  #
  def outgoing?
    ( @direction == "OUTPUT" )
  end


  #
  #  Setup any ACL for permission.
  #
  def permit( acl = nil )
    @jump = "ACCEPT"
    @acl = acl
  end

  def deny( acl = nil )
    @jump = "REJECT"
    @acl = acl
  end


  #
  #  The meat of the code.  This is designed to return the
  # actual "iptable" command which this rule can be used
  # to generate.
  #
  def to_s()
    #
    #  If there is a template - use that.
    #
    if ( template? )
      return( "template expansion" )
    end


    #
    #  If we have a port then we must include that.
    #
    port=""
    if ( ! @port.nil? )
      port="-p tcp --dport #{@port}"
    end

    #
    #  If we have a source:
    #
    s=""
    if ( ! @src.nil? )
      s="--source #{@src}"
    end

    #
    #  OK a single-rule should be sufficient.
    #
    #  TODO:  Duplicate for IPv6.
    #
    return "iptables -A #{direction} #{s} #{port} -J #{@jump}"
  end


  #
  #  Set the source
  #
  def src( new_src )
    @src = new_src
  end

  def src?
    @src
  end


  def port( new_port )
    @port = new_port
  end

  def port?
    @port
  end

  #
  #  Is there a template for this rule?
  #
  def template?
    if ( incoming? )
      File.exists?( "/usr/share/symbiosis/firewall/#{@name}.incoming" )
    else
      File.exists?( "/usr/share/symbiosis/firewall/#{@name}.outgoing" )
    end
  end
end






#
# This class allows a directory containing IP addresses to be used
# to construct either a whitelist or a blacklist of the IP addresses
# which are in that directory.
#
# For example the following directory tree will blacklist all incoming
# connections from the IP addresses 1.2.3.4, 1.4.4.4, and 10.20.30.40:
#
# .
# |--- 10.20.30.40
# |---  1.2.3.4
# \--   1.4.4.4
#
# 0 directories, 3 files
#
#
#
class DirectoryIPList

  attr_reader :directory
  attr_reader :ips



  #
  #  Read all the IP files in a given directory and store them within
  # our list.
  #
  def initialize( directory )
    @directory = directory
    @ips       = Array.new()

    throw "Directory not found #{directory}" unless
      File.directory?( directory );


    #
    #  Read teh contents of the directory
    #
    Dir.entries( directory ).each do |file|

      #
      # Skip dotfiles.
      #
      next if ( file =~ /^\./ )

      #
      #  Here we need to strip the optional ".auto" suffix.
      #
      if ( file =~ /(.*)\.auto$/i )
        file = $1.dup
      end
      @ips.push( file )
    end
  end


  #
  #  Generate appropriate IPtable rules for a whitelist
  #
  def whitelist
    result = ""

    @ips.each do |ip|
      f = FirewallRule.whitelist( ip )

      result = result + "\n# Whitelisted IP: #{ip} - #{directory}/#{ip}"
      result = result + "\n" + f.to_s
    end

    result
  end


  #
  #  Generate appropriate IPtable rules for a blacklist
  #
  def blacklist
    result = ""

    @ips.each do |ip|
      f = FirewallRule.blacklist( ip )
      result = result + "\n# Blacklisted IP: #{ip} - #{directory}/#{ip}"
      result = result + "\n" + f.to_s
    end

    result
  end

end








#
# A meta-class which represents this firewall
#
class SymbiosisFirewall

  attr_reader :incoming
  attr_reader :outgoing
  attr_reader :blacklist
  attr_reader :whitelist
  attr_reader :ipv6
  attr_reader :template


  #
  #  Constructor
  #
  def initialize()
    @ipv6 = false
#    @template =  File.open( "./firewall.erb", "r" ).read()
  end


  #
  #  Is the firewall disabled?
  #
  def disabled?
    return( File.exists?( "/etc/symbiosis/firewall/disabled" ) )
  end


  #
  #  Run a self-test upon the firewall rules.  This merely needs to
  # test that an outgoing DNS lookup succeeds, and that an external
  # ping succeeds.
  #
  #  If the test fails it will call flush().
  #
  def test()
    puts "'firewall --test' invoked.  TODO - Write code."
    0
  end


  #
  #  Flush/Remove all existing firewall rules.
  #
  def flush()
    flush_ipv4
    flush_ipv6 if ( ipv6? )
  end


  #
  #  Flush all IPv4-specific firewall rules which might be present.
  #
  def flush_ipv4
    commands = [
               "/sbin/iptables -P INPUT ACCEPT",
               "/sbin/iptables -P OUTPUT ACCEPT",
               "/sbin/iptables -P FORWARD ACCEPT",
               "/sbin/iptables -F",
               "/sbin/iptables -t nat -F",
               "/sbin/iptables -t raw -F",
               "/sbin/iptables -t mangle -F",
               "/sbin/iptables -X"
    ];

    commands.each do |cmd|
      Kernel.system( cmd )
    end
  end


  #
  #  Flush all IPv6-specific firewall rules which might be present.
  #
  def flush_ipv6
    commands = [
               "/sbin/ip6tables -P INPUT ACCEPT",
               "/sbin/ip6tables -P OUTPUT ACCEPT",
               "/sbin/ip6tables -P FORWARD ACCEPT",
               "/sbin/ip6tables -F",
               "/sbin/ip6tables -t nat -F",
               "/sbin/ip6tables -t raw -F",
               "/sbin/ip6tables -t mangle -F",
                "/sbin/ip6tables -X"
    ];

    commands.each do |cmd|
      Kernel.system( cmd )
    end
  end



  #
  # Is IPv6 enabled?
  #
  def ipv6?
    return(@ipv6)
  end



  #
  #  Read the permitted incoming rules on the filesystem.
  #
  def readIncoming
    @incoming = readRules( "/etc/symbiosis/firewall/incoming.d/" )
  end

  #
  #  Read the permitted outgoing rules on the filesystem.
  #
  def readOutgoing
    @outgoing = readRules( "/etc/symbiosis/firewall/outgoing.d/" )
  end


  #
  #  This method is the key which ties all the distinct steps together.
  #
  #  It is responsible for :
  #
  #   1.  Creating a temporary file, to write the firewall to.
  #
  #   2.  Writing out the static prefix to the firewall.
  #
  #   3.  Writing out the whitelist and blacklist parts.
  #
  #   4.  Writing out the individual rules.
  #
  #   5.  Closing and returning the name of that file.
  #
  def createFirewall()
  end


#
# Here be dragons.
#
private

  #
  #  Read from an incoming/outgoing directory and collate the results.
  #
  # TODO:  Rethink this - as here we only read the names, and we should
  #        also take account of the ACL which might be inside the file.
  #
  def readRules( directory )

    results = Array.new()

    throw "Directory not found #{directory}" unless File.directory?( directory );

    Dir.entries( directory ).each do |file|

      #
      #  Skip dotfiles
      #
      next if ( file =~ /^\./ )

      #
      #  Here we need to strip off the leading numerical prefix
      # which is only present to show sort order.
      #
      if ( file =~ /([0-9]*)-(.*)/ )
        results.push( $2.dup )
      end

    end

    #
    #  Return the names.
    #
    results
  end

end






def verbose(s)
  puts s if $VERBOSE
end




#
##
##  Entry point.
##
#######
##############



if __FILE__ == $0 then

  #
  #  Parse the arguments
  #
  $HELP     = false
  $TEMPLATE = nil
  $VERBOSE  = false
  $TEST     = false
  $FLUSH    = false
  $EXECUTE  = true
  $DELETE   = true

  opts = GetoptLong.new(
                        [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
                        [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
                        [ '--test', '-t', GetoptLong::NO_ARGUMENT ],
                        [ '--flush', '-f', GetoptLong::NO_ARGUMENT ],
                        [ '--no-execute', '-x', GetoptLong::NO_ARGUMENT ],
                        [ '--no-delete', '-d', GetoptLong::NO_ARGUMENT ]
                        )


  opts.each do |opt,arg|
    case opt
    when '--help'
      help = true
    when '--verbose'
      $VERBOSE = true
    when '--flush'
      $FLUSH = true
    when '--test'
      $TEST = true
    when '--no-execute'
      $EXECUTE = false
    when '--no-delete'
      $DELETE = false
    end
  end

  begin
    #
    #  If we're disabled exit.
    #
    myself = SymbiosisFirewall.new()
    if ( myself.disabled? )
      verbose( "Firewall disabled.  Exiting cleanly." )
      System.exit(0)
    end

    #
    #  Just testing?
    #
    if ( $TEST )
      exit( myself.test() )
    end

    #
    #  Flushing / Removing the firewall?
    #
    if ( $FLUSH )
      myself.flush()
      exit 0
    end

    #
    #  file = myself.createFirewall()
    #
    # if ( $EXECUTE )
    #  chmod( 755 , file )
    #  system( file )
    #  system( "run-parts .../local.d/" )
    # end
    # if ( $DELETE )
    #  unlink( file )
    # end
  rescue
    puts "There was an exception", $!, "\n"
  end

end



firewall = FirewallRule.blacklist( "1.2.3.4" )
puts firewall

firewall = FirewallRule.whitelist( "1.2.3.4" )
puts firewall


f = DirectoryIPList.new( "./blacklist.d" )
puts f.whitelist
