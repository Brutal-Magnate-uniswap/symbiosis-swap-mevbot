#!/usr/bin/ruby

require 'getoptlong'
require 'singleton'


#
# This is a helper-class designed to lookup the appropriate port
# number for a given service.  It is a singleton.
#
class PortLookup
 include Singleton

  #
  #  Return the port number for the given service
  #
  def lookup( name )

    #
    #  It was already numeric?
    #
    if ( name =~ /^([0-9]+)$/ )
      return name.to_i
    end

    #
    #  Otherwise load the data from /etc/services
    #
  end
end



#
#  This class encapsulates a single firewall (iptables) rule.
#
class FirewallRule

  attr_reader :port
  attr_reader :jump
  attr_reader :direction
  attr_reader :source
  attr_reader :acl


  #
  #  Constructor
  #
  def initialize( name )
    @direction = nil
    @jump      = nil
    @src       = nil
    @port      = nil
    @acl       = nil
  end

  #
  #  Helper
  #
  def FirewallRule.blacklist( ip )
    f = FirewallRule.new( "blacklist-#{ip}" )
    f.incoming()
    f.src( ip)
    f.deny()
    return f
  end

  #
  #  Helper
  #
  def FirewallRule.whitelist( ip )
    f = FirewallRule.new( "whitelist-#{ip}" )
    f.incoming()
    f.src( ip )
    f.permit()
    return f
  end


  #
  #  Set this rule to work against incoming connections.
  #
  def incoming
    @direction = "INPUT"
  end


  #
  #  Is this incoming?
  #
  def incoming?
    return( @direction == "INPUT" )
  end


  #
  # Set this rule to work against outgoing connections.
  #
  def outgoing
    @direction = "OUTPUT"
  end


  #
  #  Is this an outgoing rule?
  #
  def outgoing?
    ( @direction == "OUTPUT" )
  end


  #
  #  Setup any ACL for permission.
  #
  def permit( acl = nil )
    @jump = "ACCEPT"
    @acl = acl
  end

  def deny( acl = nil )
    @jump = "REJECT"
    @acl = acl
  end

  #
  #  The meat of the code.  This is designed to return the
  # actual "iptable" command which this rule can be used
  # to generate.
  #
  def to_s()
    #
    #  If there is a template - use that.
    #
    if ( template? )
      return( "template expansion" )
    end


    #
    #  If we have a port then we must include that.
    #
    port=""
    if ( ! @port.nil? )
      port="-p tcp --dport #{@port}"
    end

    #
    #  If we have a source:
    #
    s=""
    if ( ! @src.nil? )
      s="--source #{@src}"
    end

    #
    #  If we have an ACL then we need to repeat for each one.
    #
    if ( ! @acl.nil? )
      ret = ""

      @acl.each do |ip|
        ret = ret + "iptables -A #{direction} --source #{ip} #{port} -J #{@jump}\n"
      end
      return ret;
    end

    #
    #  OK a straight-forward single-rule
    #
    return "iptables -A #{direction} #{s} #{port} -J #{@jump}"
  end


  #
  #  Set the source
  #
  def src( new_src )
    @src = new_src
  end

  def src?
    @src
  end


  def port( new_port )
    @port = new_port
  end

  def port?
    @port
  end

  #
  #  Is there a template for this rule?
  #
  def template?
    if ( incoming? )
      File.exists?( "/usr/share/symbiosis/firewall/#{@name}.incoming" )
    else
      File.exists?( "/usr/share/symbiosis/firewall/#{@name}.outgoing" )
    end
  end
end






#
# A meta-class which represents this firewall
#
class SymbiosisFirewall

  attr_reader :incoming, :outgoing, :blacklist, :whitelist
  attr_reader :ipv6


  #
  #  Constructor
  #
  def initialize()
    @ipv6 = false
  end


  #
  #  Is the firewall disabled?
  #
  def disabled?
    return( File.exists?( "/etc/symbiosis/firewall/disabled" ) )
  end


  #
  # Control whether IPv6 is enabled.
  #
  def ipv6( enabled = false )
    @ipv6 = enabled
  end


  #
  # Is IPv6 enabled?
  #
  def ipv6?
    return(@ipv6)
  end



  #
  #  Read the permitted incoming rules on the filesystem.
  #
  def readIncoming
    @incoming = readRules( "/etc/symbiosis/firewall/incoming.d/" )
  end

  #
  #  Read the permitted outgoing rules on the filesystem.
  #
  def readOutgoing
    @outgoing = readRules( "/etc/symbiosis/firewall/outgoing.d/" )
  end

  #
  #  Read the IPs that are blacklisted.
  #
  def readBlacklist
    @blacklist = readIPS( "/etc/symbiosis/firewall/blacklist.d/" )
  end

  #
  #  Read the IPs that are whitelisted
  #
  def readWhitelist
    @whitelist = readIPS( "/etc/symbiosis/firewall/whitelist.d/" )
  end


  def createFirewall()
    # 1.  create a temporary file.
    # 2.  expand our simple template into it.
    # 3.  Add the blacklist
    # 4.  Add the whitelist
    # 5.  Add the incoming rules.
    # 6.  Add the outgoing rules.
  end

#
# Here be dragons.
#
private

  #
  #  Read from an incoming/outgoing directory and collate the results.
  #
  # TODO:  Rethink this - as here we only read the names, and we should
  #        also take account of the ACL which might be inside the file.
  #
  def readRules( directory )

    results = Array.new()

    throw "Directory not found #{directory}" unless File.directory?( directory );

    Dir.entries( directory ).each do |file|

      #
      #  Here we need to strip off the leading numerical prefix
      # which is only present to show sort order.
      #
      if ( file =~ /([0-9]*)-(.*)/ )
        results.push( $2.dup )
      end

    end

    #
    #  Return the names.
    #
    results
  end


  #
  #  Read from a blacklist/whitelist directory
  #
  def readIPS( directory )
    results = Array.new()

    throw "Directory not found #{directory}" unless File.directory?( directory );

    Dir.entries( directory ).each do |file|

      #
      #  Here we need to strip the optional ".auto" suffix.
      #
      if ( file =~ /(.*)\.auto$/i )
        file = $1.dup
      end
      results.push( file )
    end

    #
    #  Return the IPs.
    #
    results
  end

end




def verbose(s)
  puts s if $VERBOSE
end


if __FILE__ == $0 then

  #
  #  Parse the arguments
  #
  $HELP     = false
  $TEMPLATE = nil
  $VERBOSE  = false

  opts = GetoptLong.new(
                        [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
                        [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ]
                        )


  begin
    #
    #  If we're disabled exit.
    #
    myself = SymbiosisFirewall.new()
    if ( myself.disabled? )
      verbose( "Firewall disabled" )
      System.exit(0)
    end

    #
    #  Collate the rules.
    #
    myself.readIncoming()

  rescue
    puts "There was an exception", $!, "\n"
  end

end



firewall = FirewallRule.blacklist( "1.2.3.4" )
puts firewall

firewall = FirewallRule.whitelist( "1.2.3.4" )
puts firewall
