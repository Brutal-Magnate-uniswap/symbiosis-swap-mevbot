#!/usr/bin/perl


=head1 NAME

firewall-blacklist - A simple script to mitigate dictionary attacks.

=cut


=head1 SYNOPSIS


  Options:

   --attempts    Specify the number of failing attempts before blacklisting.
                 (Default 20 failing logins.)

   --dump        Just dump loaded rules.

   --expire      The number of days to keep blacklisted records.
                 (Default two days)

   --input       The directory where our pattern files are located.


  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.

=cut



=head1 ABOUT

This script is designed to look over the system logs and blacklist
hosts which appear to be performing dictionary attacks; that is making
multiple connection attempts with different usernames and passwords
and attempting to login to systems they shouldn't.

The way that the script detects addresses which are worthy of blacklisting
is via the use of pattern files.  All pattern files located beneath
B</etc/symbiosis/firewall/patterns.d/> are loaded and applied.

The pattern files contain the name of a logfile to examine and a list
of regular expressions which will be tested for within that named logfile.

Any IPs which are blocked will be logged to syslog, and similarly the
removal of the blocks will also be logged to syslog.

=cut


=head1 DISABLING

If you don't wish to use this script simply touch the file:

=for example begin

  /etc/symbiosis/firewall/disabled.blacklist

=for example end

=cut


=head1 WHITELISTING

The file /etc/symbiosis/firewall/whitelist.d/ will be consulted - any IP
address listed in that directory will be ignored.

=cut


=head1 AUTHOR

 Steve
 --

=cut



=head1 LICENSE

Copyright (c) 2008-2010 by Bytemark Computer Consulting Ltd.  All rights reserved.

This program is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;

use English;
use File::Basename;
use Getopt::Long;
use Pod::Usage;
use Sys::Syslog;



#
#  Configuration variables
#
my %CONFIG;
$CONFIG{ 'input' }     = "/etc/symbiosis/firewall/patterns.d/";
$CONFIG{ 'blacklist' } = "/etc/symbiosis/firewall/blacklist.d/";
$CONFIG{ 'whitelist' } = "/etc/symbiosis/firewall/whitelist.d/";
$CONFIG{ 'verbose' }   = 0;
$CONFIG{ 'attempts' } = 20;    # count of attacks before blacklisting
$CONFIG{ 'expire' }   = 2;     # number of days to keep records



#
#  Parse command line arguments
#
parseCommandLineArguments();


#
#  If the firewall is disabled then exit
#
if ( -e "/etc/symbiosis/firewall/disabled" )
{
    $CONFIG{ 'verbose' } && print "Firewall disabled\n";

    exit;
}

#
#  If just the blacklister is disabled then exit
#
if ( -e "/etc/symbiosis/firewall/disabled.blacklist" )
{
    $CONFIG{ 'verbose' } && print "Blacklister disabled\n";
    cleanBlacklist();

    #
    #  If we're disabled and we were disabled "recently" then
    # reload the firewall to make sure changes take effect.
    #
    if ( ( -x "/usr/bin/firewall" ) &&
         ( recentlyModified("/etc/symbiosis/firewall/disabled") ) )
    {
        $CONFIG{ 'verbose' } && print "Reloading firewall\n";

        #
        #  Ensure we log sanely.
        #
        my $log = " >>/var/log/firewall.log 2>>/var/log/firewall.err";

        system("/usr/bin/firewall $log");
    }
    exit;
}


#
#  Sanity check system
#
sanityCheckSystem();


#
#  Exit if we have no rules
#
rulesPresent() || exit;


#
#  Load the rules
#
my $RULES = loadRules();

#
#  Just dumping?
#
if ( $CONFIG{ 'dump' } )
{
    use Data::Dumper;
    print Dumper( \$RULES );
    exit;
}

#
#  Open syslog
#
my $prog = basename($0);
openlog( $prog, 'pid', 'user' );


#
#  Do we need to reload?
#
my $reload = 0;

#
#  Process the rules
#
foreach my $ruleset (@$RULES)
{
    $reload += processRules($ruleset);
}


#
#  Remove old blacklisted IPs
#
$reload += expireBlacklist();


#
#  Reload the firewall?
#
if ($reload)
{
    $CONFIG{ 'verbose' } && print "Reloading firewall ..\n";
    system("/usr/bin/firewall");
    $CONFIG{ 'verbose' } && print "firewall reloaded ..\n";
}


#
# Close syslog
#
closelog();


#
#  All done
#
exit;




=begin doc

  Parse the command line arguments we've been given.

=end doc

=cut



sub parseCommandLineArguments
{

    my $HELP   = 0;
    my $MANUAL = 0;

    #  Parse options.
    #
    if (
         !GetOptions( "attempts=s", \$CONFIG{ 'attempts' },
                      "expire=s",   \$CONFIG{ 'expire' },
                      "help",       \$HELP,
                      "input=s",    \$CONFIG{ 'input' },
                      "dump",       \$CONFIG{ 'dump' },
                      "manual",     \$MANUAL,
                      "verbose",    \$CONFIG{ 'verbose' },
                    ) )
    {
        exit;
    }

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;

}



=begin doc

  Sanity check the host system.

=end doc

=cut



sub sanityCheckSystem
{

    #
    #  Make sure the input directory exists.
    #
    if ( !-d $CONFIG{ 'input' } )
    {
        print "The input directory doesn't exist: $CONFIG{'input'}\n";
        exit;
    }

    #
    #  Make sure we're root
    #
    if ( ( $EFFECTIVE_USER_ID != 0 ) && ( !$CONFIG{ 'no-root' } ) )
    {
        print "You must be root to use this script appropriately\n";
        exit;
    }

    #
    #  Make sure the attempts is a number
    #
    if ( $CONFIG{ 'attempts' } !~ /^([0-9]+)$/ )
    {
        $CONFIG{ 'attempts' } = 20;
    }


    #
    #  Make sure the expiry period is a number
    #
    if ( $CONFIG{ 'expire' } !~ /^([0-9]+)$/ )
    {
        $CONFIG{ 'expire' } = 2;
    }
}



=begin doc

  See if we have blacklist rules present.

=end doc

=cut



sub rulesPresent
{
    my $count = 0;

    foreach my $file ( sort( glob( $CONFIG{ 'input' } . "/*.patterns" ) ) )
    {
        $CONFIG{ 'verbose' } && print "Blacklist pattern found: $file\n";
        $count += 1;
    }

    return $count;
}



=begin doc

  Load each of our rules.

  We return an array reference to a collection of hashes.

=end doc

=cut


sub loadRules
{
    my $rules;


    #
    #  Load *.patterns
    #
    foreach my $file ( sort( glob( $CONFIG{ 'input' } . "/*.patterns" ) ) )
    {

        #
        #  The data associated with each file.
        #
        my $data;


        open( FILE, "<", $file ) or
          die "failed to read file $file - $!";

        foreach my $line (<FILE>)
        {

            #
            #  Remove trailing newline, and skip empty lines or comments.
            #
            chomp($line);
            next if ( !length($line) || ( $line =~ /^#/ ) );

            #
            #  Filename
            #
            if ( $line =~ /file\s+=\s+(.*)/ )
            {
                $data->{ 'file' } = $1;
            }
            elsif ( $line =~ /ports\s+=\s+(.*)/ )
            {
                my $ports = $1;
                $ports =~ s/^\s*//;
                $ports =~ s/\s*$//;

                $data->{ 'ports' } = $ports;
            }
            else
            {

                # rules
                my $cur = $data->{ 'rules' };
                push( @$cur, $line );
                $data->{ 'rules' } = $cur;
            }
        }
        close(FILE);

        if ( $data && keys %$data )
        {
            push( @$rules, $data );
        }
    }

    return ($rules);
}



=begin doc

  Given a set of rules, which compromises of a filename, a list of patterns
 and an optional port list, then test it

=end doc

=cut

sub processRules
{
    my ($rule) = (@_);

    #
    #  The data from the ruleset.
    #
    my $file  = $rule->{ 'file' };
    my $ports = $rule->{ 'ports' } || "all";
    my @rules = @{ $rule->{ 'rules' } };

    #
    #  Pattern to match an IP address, including the ::ffff: prefix.
    #
    #  TODO: Make sure we also have IPv6 patterns in the future.
    #
    my $ip = "(?:::ffff:)?([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)";

    #
    #  IPs we see accessing.
    #
    my %IPS;

    #
    #  List ports the given IP has accessed.
    #
    my %PORTS;


    #
    #  If the file doesn't exist we'll return
    #
    if ( !-e $file )
    {
        $CONFIG{ 'verbose' } && print "Named logfile doesn't exist: $file\n";
        return 0;
    }


    #
    #  Read the file, using the logtail script so we only
    # process new additions.
    #
    open( FILE, "/usr/bin/firewall-logtail $file|" ) or
      die "failed to read logfile: $file - $!";

    #
    #  Process each line
    #
    foreach my $line (<FILE>)
    {

        #
        #  Skip empty lines, and remove newlines.
        #
        next if ( !defined($line) || !length($line) );
        chomp($line);
        next if ( !defined($line) || !length($line) );

        #
        #  Process each line against our patterns.
        #
        foreach my $rule (@rules)
        {

            #
            #  Insert the IP matching regexp
            #
            $rule =~ s/__IP__/$ip/g if ( $rule =~ /__IP__/ );

            #
            #  If the line in the file matches the rule then
            # we know that $1 is the IP address of the offending system.
            #
            if ( $line =~ /$rule/i )
            {
                my $match = $1;

                #
                # We make two records here.
                #
                ##
                #
                #  $IPS{"1.2.3.4"} which matches the attack from 1.2.3.4
                #
                #  $PORTS{"1.2.3.4"}{22} which is the port-specific count.
                #
                ##
                #
                $PORTS{ $match }->{ $ports } += 1;
                $IPS{ $match } += 1;
            }
        }
    }
    close(FILE);



    #
    #  Now for each dropping host we'll have a multi-dimensional
    # hash which looks like:
    #
    #   $PORTS{'1.2.3.4'}{'22'} = 23
    #
    #  That shows that the IP 1.2.3.4 hit port 22 23 times
    #
    #
    #  We'll also have:
    #
    #   $IPS{'1.2.3.4'} = 23;
    #
    #  Which shows we saw 23 hits from the given IP - where the
    # port accessed is irrelevant.
    #
    my $count = 0;
    foreach my $ip ( keys %IPS )
    {

        #
        # ignore local failures.
        #
        next if ( $ip =~ /^127/ );

        #
        # Ignore whitelisted IPs
        #
        next
          if ( ( -e $CONFIG{ 'whitelist' } . "/$ip" ) ||
               ( -e $CONFIG{ 'whitelist' } . "/$ip.auto" ) );


        #
        # Get the global count for this IP.
        #
        my $attempts = $IPS{ $ip };

        #
        # If too high we want to block each port they've
        # accessed.
        #
        if ( $attempts >= $CONFIG{ 'attempts' } )
        {

            #
            #  If they're not already blacklisted.
            #
            if ( !-e "$CONFIG{'blacklist'}/$ip.auto" )
            {

                #
                #  Ensure there is a blacklist directory
                #
                if ( !-d "$CONFIG{'blacklist'}" )
                {
                    system( "mkdir", "-p", $CONFIG{ 'blacklist' } );
                }


                #
                #  Write out the record.
                #
                open( LOG, ">", "$CONFIG{'blacklist'}/$ip.auto" );


                #
                #  Write out the ports they accessed.
                #
                foreach my $p ( keys %{ $PORTS{ $ip } } )
                {
                    if ( ($p) && ( $p !~ /^all$/i ) )
                    {
                        foreach my $block ( split( /,/, $p ) )
                        {
                            print LOG $block . "\n";
                        }
                    }
                }
                close(LOG);

                $CONFIG{ 'verbose' } && print "Blacklisting: $ip\n";

                #
                # log the new block to syslog.
                #
                syslog( 'info', "firewall-blacklist adding: $ip" );

                $count += 1;
            }
            else
            {
                $CONFIG{ 'verbose' } &&
                  print "Ignoring blacklisted IP: $ip\n";
            }
        }
        else
        {
            $CONFIG{ 'verbose' } &&
              print
              "Allowing IP $ip only made $attempts (<$CONFIG{'attempts'} ) attempts\n";
        }
    }


    #
    #  Return the count of IPs we blacklisted.
    #
    return ($count);
}



=begin doc

  Expire entries from the blacklist which are more than two days old.

=end doc

=cut

sub expireBlacklist
{

    #
    #  Changed anything?
    #
    my $changed = 0;

    #
    #  Remove any auto-added file which is older than our threshold.
    #
    foreach my $file ( sort( glob("$CONFIG{'blacklist'}/*.auto") ) )
    {
        next unless ( -e $file );

        my $age = -M $file;
        $age    = 0 if ( !defined($age) );

        if ( int($age) > $CONFIG{ 'expire' } )
        {
            $CONFIG{ 'verbose' } && print "Expiring file: $file\n";

            unlink($file);


            my $ip = $file;
            if ( $ip =~ /(.*)\/(.*)\.auto$/i )
            {
                $ip = $2;
            }

            syslog( 'info', "firewall-blacklist removing: $ip" );
            $changed += 1;
        }

    }

    #
    #  Remove any blacklisted IP which is now on our whitelist.
    #
    foreach my $file ( sort ( glob("$CONFIG{'blacklist'}/*") ) )
    {

        #
        #  Get the IP
        #
        my $ip = $file;
        if ( $ip =~ /(.*)\/(.*)\.auto$/i )
        {
            $ip = $2;
        }

        #
        #  If that IP was whitelisted after blocking then remove it.
        #
        if ( -e $CONFIG{ 'whitelist' } . "/$ip" )
        {
            $CONFIG{ 'verbose' } &&
              print "Removing file: $file due to it being whitelisted.\n";
            unlink($file);

            syslog( 'info', "firewall-blacklist removing: $ip" );

            $changed += 1;
        }
    }


    return ($changed);
}



=begin doc

  Remove all auto-generated blacklisted entries.

=end doc

=cut

sub cleanBlacklist
{
    foreach my $ip ( sort( glob("$CONFIG{'blacklist'}/*.auto") ) )
    {
        my $file = $ip;

        if ( $file =~ /\/(.*)\.auto/i )
        {
            $file = $1;
        }
        $CONFIG{ 'verbose' } &&
          print "Removing previously blacklisted file: $file\n";
        unlink($ip);
    }
}


=begin doc

  Return 1 if the specified file was modified "recently".

=end doc

=cut

sub recentlyModified
{
    my ( $filename, $threshold ) = (@_);

    #
    #  File not present?  Not modified then.
    #
    return 0 unless ( -e $filename );

    #
    #  Our threshold: six hours unless overridden
    #
    my $thresh = $threshold;
    if ( !defined($thresh) )
    {
        $thresh = 60 * 60 * 6;
    }

    my ( $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
         $size, $atime, $mtime, $ctime, $blksize, $blocks
       ) = stat($filename);

    #
    #  Current date
    #
    my $now = time;

    if ( abs( $now - $mtime ) < $thresh )
    {
        return 1;
    }
    if ( abs( $now - $ctime ) < $thresh )
    {
        return 1;
    }

    return 0;
}
