#!/usr/bin/perl


=head1 NAME

firewall-blacklist - A simple script to mitigate against dictionary attacks.

=cut


=head1 SYNOPSIS


  Options:

   --attempts    Specify the number of failing attempts before blacklisting.
                 (Default five failing logins.)

   --dump        Just dump loaded rules.

   --expire      The number of days to keep blacklisted records.
                 (Default two days)

   --input       The directory where our pattern files are located.


  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.

=cut



=head1 ABOUT

  This script is designed to look over the system logs and blacklist
 hosts which are attempting dictionary attacks.

=cut


=head1 DISABLING

  If you don't wish to use this script simply touch the file:

=for example begin

  /etc/firewall/disabled.blacklist

=for example end

=cut


=head1 WHITELISTING

 The file /etc/firewall/whitelist.d/ will be consulted - any IP address
 listed in that directory will be ignored.

=cut


=head1 AUTHOR

 Steve
 --

=cut



=head1 LICENSE

Copyright (c) 2008,2009 by Bytemark Computer Consulting Ltd.  All rights reserved.

This program is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;

use English;
use Getopt::Long;
use Pod::Usage;



#
#  Configuration variables
#
my %CONFIG;
$CONFIG{ 'input' }     = "/etc/firewall/patterns.d/";
$CONFIG{ 'blacklist' } = "/etc/firewall/blacklist.d/";
$CONFIG{ 'whitelist' } = "/etc/firewall/whitelist.d/";
$CONFIG{ 'verbose' }   = 0;
$CONFIG{ 'attempts' } = 20;    # count of attacks before blacklisting
$CONFIG{ 'expire' }   = 2;     # number of days to keep records



#
#  Parse command line arguments
#
parseCommandLineArguments();


#
#  If the firewall is disabled then exit
#
if ( -e "/etc/firewall/disabled" )
{
    $CONFIG{ 'verbose' } && print "Firewall disabled\n";

    exit;
}

#
#  If just the blacklister is disabled then exit
#
if ( -e "/etc/firewall/disabled.blacklist" )
{
    $CONFIG{ 'verbose' } && print "Blacklister disabled\n";
    cleanBlacklist();

    #
    #  If we're disabled and we were disabled "recently" then
    # reload the firewall to make sure changes take effect.
    #
    if ( ( -x "/usr/bin/firewall" ) &&
         ( recentlyModified("/etc/firewall/disabled") ) )
    {
        $CONFIG{ 'verbose' } && print "Reloading firewall\n";
        system("/usr/bin/firewall");
    }
    exit;
}


#
#  Sanity check system
#
sanityCheckSystem();


#
#  Exit if we have no rules
#
rulesPresent() || exit;


#
#  Load the rules
#
my $RULES = loadRules();

#
#  Just dumping?
#
if ( $CONFIG{ 'dump' } )
{
    use Data::Dumper;
    print Dumper( \$RULES );
    exit;
}

#
#  Do we need to reload?
#
my $reload = 0;

#
#  Process the rules
#
foreach my $ruleset (@$RULES)
{
    $reload += processRules($ruleset);
}


#
#  Remove old blacklisted IPs
#
$reload += expireBlacklist();


#
#  Reload the firewall?
#
if ($reload)
{
    $CONFIG{ 'verbose' } && print "Reloading firewall ..\n";
    system("/usr/bin/firewall");
    $CONFIG{ 'verbose' } && print "firewall reloaded ..\n";
}


#
#  All done
#
exit;




=begin doc

  Parse the command line arguments we've been given.

=end doc

=cut



sub parseCommandLineArguments
{

    my $HELP   = 0;
    my $MANUAL = 0;

    #  Parse options.
    #
    if (
         !GetOptions( "attempts=s", \$CONFIG{ 'attempts' },
                      "expire=s",   \$CONFIG{ 'expire' },
                      "help",       \$HELP,
                      "input=s",    \$CONFIG{ 'input' },
                      "dump",       \$CONFIG{ 'dump' },
                      "manual",     \$MANUAL,
                      "verbose",    \$CONFIG{ 'verbose' },
                    ) )
    {
        exit;
    }

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;

}



=begin doc

  Sanity check the host system.

=end doc

=cut



sub sanityCheckSystem
{

    #
    #  Make sure the input directory exists.
    #
    if ( !-d $CONFIG{ 'input' } )
    {
        print "The input directory doesn't exist: $CONFIG{'input'}\n";
        exit;
    }

    #
    #  Make sure we're root
    #
    if ( ( $EFFECTIVE_USER_ID != 0 ) && ( !$CONFIG{ 'no-root' } ) )
    {
        print "You must be root to use this script appropriately\n";
        exit;
    }

    #
    #  Make sure the attempts is a number
    #
    if ( $CONFIG{ 'attempts' } !~ /^([0-9]+)$/ )
    {
        $CONFIG{ 'attempts' } = 5;
    }


    #
    #  Make sure the expiry period is a number
    #
    if ( $CONFIG{ 'expire' } !~ /^([0-9]+)$/ )
    {
        $CONFIG{ 'expire' } = 2;
    }
}



=begin doc

  See if we have blacklist rules present.

=end doc

=cut



sub rulesPresent
{
    my $count = 0;

    foreach my $file ( sort( glob( $CONFIG{ 'input' } . "/*.patterns" ) ) )
    {
        $CONFIG{ 'verbose' } && print "Blacklist pattern found: $file\n";
        $count += 1;
    }

    return $count;
}



=begin doc

  Load each of our rules.

  We return an array reference to a collection of hashes.

=end doc

=cut


sub loadRules
{
    my $rules;


    #
    #  Load *.patterns
    #
    foreach my $file ( sort( glob( $CONFIG{ 'input' } . "/*.patterns" ) ) )
    {

        #
        #  The data associated with each file.
        #
        my $data;


        open( FILE, "<", $file ) or
          die "failed to read file $file - $!";

        foreach my $line (<FILE>)
        {

            #
            #  Remove trailing newline, and skip empty lines or comments.
            #
            chomp($line);
            next if ( !length($line) || ( $line =~ /^#/ ) );

            #
            #  Filename
            #
            if ( $line =~ /file\s+=\s+(.*)/ )
            {
                $data->{ 'file' } = $1;
            }
            elsif ( $line =~ /ports\s+=\s+(.*)/ )
            {
                my $ports = $1;
                $ports =~ s/^\s*//;
                $ports =~ s/\s*$//;

                $data->{ 'ports' } = $ports;
            }
            else
            {

                # rules
                my $cur = $data->{ 'rules' };
                push( @$cur, $line );
                $data->{ 'rules' } = $cur;
            }
        }
        close(FILE);

        if ( $data && keys %$data )
        {
            push( @$rules, $data );
        }
    }

    return ($rules);
}



=begin doc

  Given a set of rules, which compromises of a filename, a list of patterns
 and an optional port list, then test it

=end doc

=cut

sub processRules
{
    my ($rule) = (@_);

    #
    #  The data from the ruleset.
    #
    my $file  = $rule->{ 'file' };
    my $ports = $rule->{ 'ports' } || "all";
    my @rules = @{ $rule->{ 'rules' } };

    #
    #  Pattern to match an IP address.
    #
    my $ip = "([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)";

    #
    #  List of IPs to blacklist
    #
    my %BLACKLIST;

    #
    #  If the file doesn't exist we'll return
    #
    if ( !-e $file )
    {
        $CONFIG{ 'verbose' } && print "Named logfile doesn't exist: $file\n";
        return 0;
    }


    open( FILE, "/usr/bin/firewall-logtail $file|" ) or
      die "failed to read logfile: $file - $!";

    foreach my $line (<FILE>)
    {
        next if ( !defined($line) || !length($line) );
        chomp($line);
        next if ( !defined($line) || !length($line) );

        foreach my $rule (@rules)
        {

            #
            #  Insert the IP matching regexp
            #
            $rule =~ s/__IP__/$ip/g if ( $rule =~ /__IP__/ );

            #
            #  If the line in the file matches the rule then
            # we know that $1 is the IP address of the offending system.
            #
            if ( $line =~ /$rule/i )
            {
                my $match = $1;

                #
                # Record the blacklist
                #
                $BLACKLIST{ $match }->{ $ports } += 1;
            }
        }
    }
    close(FILE);

    #
    #  Now for each dropping host we'll have a multi-dimensional
    # hash which looks like:
    #
    #   $HASH{'1.2.3.4'}{'22'} = 23
    #
    #  That shows that the IP 1.2.3.4 hit port 22 23 times
    #
    #


    my $count = 0;
    foreach my $ip ( keys %BLACKLIST )
    {

        #
        # ignore local failures.
        #
        next if ( $ip =~ /^127/ );

        #
        # Ignore whitelisted IPs
        #
        next if ( -e $CONFIG{ 'whitelist' } . "/$ip" );

        #
        # The ports which were affected.
        #
        foreach my $p ( keys %{ $BLACKLIST{ $ip } } )
        {

            my $attempts = $BLACKLIST{ $ip }->{ $p };
            if ( $attempts >= $CONFIG{ 'attempts' } )
            {
                if ( !-e "$CONFIG{'blacklist'}/$ip.auto" )
                {
                    if ( !-d "$CONFIG{'blacklist'}" )
                    {
                        system( "mkdir", "-p", $CONFIG{ 'blacklist' } );
                    }

                    open( LOG, ">", "$CONFIG{'blacklist'}/$ip.auto" );
                    if ( ($p) && ( $p !~ /^all$/i ) )
                    {
                        foreach my $block ( split( /,/, $p ) )
                        {
                            print LOG $block . "\n";
                        }
                    }
                    close(LOG);

                    $CONFIG{ 'verbose' } && print "Blacklisting: $ip\n";
                    $count += 1;
                }
                else
                {
                    $CONFIG{ 'verbose' } &&
                      print "Ignoring blacklisted IP: $ip\n";
                }
            }
            else
            {
                $CONFIG{ 'verbose' } &&
                  print
                  "Allowing IP $ip only made $attempts (<$CONFIG{'attempts'} ) attempts\n";
            }
        }
    }


    #
    #  Return the count of IPs we blacklisted.
    #
    return ($count);
}



=begin doc

  Expire entries from the blacklist which are more than two days old.

=end doc

=cut

sub expireBlacklist
{

    #
    #  Changed anything?
    #
    my $changed = 0;

    #
    #  Remove any auto-added file which is older than our threshold.
    #
    foreach my $file ( sort( glob("$CONFIG{'blacklist'}/*.auto") ) )
    {
        my $age = -M $file;
        if ( int($age) > $CONFIG{ 'expire' } )
        {
            $CONFIG{ 'verbose' } && print "Expiring file: $file\n";

            unlink($file);

            $changed += 1;
        }

    }

    #
    #  Remove any blacklisted IP which is now on our whitelist.
    #
    foreach my $file ( sort ( glob("$CONFIG{'blacklist'}/*") ) )
    {

        #
        #  Get the IP
        #
        my $ip = $file;
        if ( $ip =~ /(.*)\/(.*)\.auto$/i )
        {
            $ip = $2;
        }

        #
        #  If that IP was whitelisted after blocking then remove it.
        #
        if ( -e $CONFIG{ 'whitelist' } . "/$ip" )
        {
            $CONFIG{ 'verbose' } &&
              print "Removing file: $file due to it being whitelisted.\n";
            unlink($file);
            $changed += 1;
        }
    }


    return ($changed);
}



=begin doc

  Remove all auto-generated blacklisted entries.

=end doc

=cut

sub cleanBlacklist
{
    foreach my $ip ( sort( glob("$CONFIG{'blacklist'}/*.auto") ) )
    {
        my $file = $ip;

        if ( $file =~ /\/(.*)\.auto/i )
        {
            $file = $1;
        }
        $CONFIG{ 'verbose' } &&
          print "Removing previously blacklisted file: $file\n";
        unlink($ip);
    }
}


=begin doc

  Return 1 if the specified file was modified "recently".

=end doc

=cut

sub recentlyModified
{
    my ( $filename, $threshold ) = (@_);

    #
    #  File not present?  Not modified then.
    #
    return 0 unless ( -e $filename );

    #
    #  Our threshold: six hours unless overridden
    #
    my $thresh = $threshold;
    if ( !defined($thresh) )
    {
        $thresh = 60 * 60 * 6;
    }

    my ( $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
         $size, $atime, $mtime, $ctime, $blksize, $blocks
       ) = stat($filename);

    #
    #  Current date
    #
    my $now = time;

    if ( abs( $now - $mtime ) < $thresh )
    {
        return 1;
    }
    if ( abs( $now - $ctime ) < $thresh )
    {
        return 1;
    }

    return 0;
}
