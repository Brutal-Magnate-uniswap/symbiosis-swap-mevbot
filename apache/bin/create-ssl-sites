#!/usr/bin/perl -w
#
#  This script is designed to create a new Apache virtual host for
# each site upon the local host which is configured for SSL but which
# doesn't already have an SSL site generated.
#
# Steve
# --
#

use strict;
use warnings;
use Getopt::Long;



#
#  Configuration variables.
#
my %CONFIG;


#
#  Default prefix
#
$CONFIG{ 'prefix' } = "/srv";



#
#  Parse any command line arguments.
#
parseCommandLineArguments();


#
#  Now look for domains
#
my @domains = findAllWebDomains( $CONFIG{ 'prefix' } );


#
#  Process each domain
#
foreach my $domain (@domains)
{
    $CONFIG{ 'verbose' } && print "Testing $domain\n";

    $CONFIG{ 'changed' } += testDomain($domain);

    $CONFIG{ 'verbose' } && print "done\n";
}



#
#  Reload Apache if we made changes.
#
if ( $CONFIG{ 'changed' } )
{
    $CONFIG{ 'verbose' } && print "Reloading Apache\n";

    system("/etc/init.d/apache2 reload >/dev/null");

    $CONFIG{ 'verbose' } && print "done.\n";
}



=begin doc

  Parse any command line arguments which might be present.

=end doc

=cut



sub parseCommandLineArguments
{
    if (
         !GetOptions( "verbose",  \$CONFIG{ 'verbose' },
                      "prefix=s", \$CONFIG{ 'prefix' }, ) )
    {
        exit;
    }

}



=begin doc

  Find all domains that have a public/htdocs/ directory

=end doc

=cut


sub findAllWebDomains
{
    my ($prefix) = (@_);

    my @results;

    foreach my $entry ( sort( glob( $prefix . "/*/public/htdocs" ) ) )
    {
        if ( -d $entry )
        {

            #
            #  We only care about the domain name.
            #
            if ( $entry =~ /[\\\/]([^\\\/]+)\/public\/htdocs/ )
            {
                push( @results, $1 );
            }
        }

    }

    return (@results);
}



=begin doc

  Test the domain specified to see if it has:

  1.  An SSL key.
  2.  A non-default IP address.

  If so create a new apache SSL configuration file for it, and return 1
 so that apache is restarted.

=end doc

=cut


sub testDomain
{
    my ($domain) = (@_);

    #
    #  We need to look for:
    #
    #  /srv/$domain/config/ssl.key
    #  /srv/$domain/config/ip
    #
    #  If they are not present then we're not going to even think about
    # being SSL-aware.
    #
    return 0 if ( !-e $CONFIG{ 'prefix' } . "/$domain/config/ssl.key" );
    return 0 if ( !-e $CONFIG{ 'prefix' } . "/$domain/config/ip" );

    #
    #  OK we have an SSL Key - we also have an IP.
    #
    #  So we need to check:
    #
    #   1.  Is this IP different from the primary IP?
    #
    #  Get the IP from the file
    #
    open( IP, "<", "$CONFIG{'prefix'}/$domain/config/ip" ) or
      die "Failed to read file - $!";
    my $ip = <IP>;
    close(IP);
    chomp($ip);

    #
    #  Get the primary IP of the system to see if the IP matches.
    #
    my $host = findHostDetails();
    if ( $host eq $ip )
    {
        return 0;
    }

    #
    # Is there already an SSL site available for this domain?
    #
    # If there is we'll return, unless either the SSL key or bundle
    # is newer than that generated file.
    #
    if ( -e "/etc/apache2/sites-enabled/$domain.ssl" )
    {

        #
        #  See when the generated file was created.
        #
        my $site = createdTime("/etc/apache2/sites-enabled/$domain.ssl");

        #
        #  See when the SSL key was created.
        #
        my $key =
          createdTime( $CONFIG{ 'prefix' } . "/$domain/config/ssl.key" );


        if ( -e $CONFIG{ 'prefix' } . "/$domain/config/ssl.bundle" )
        {
            my $bundle =
              createdTime( $CONFIG{ 'prefix' } . "/$domain/config/ssl.bundle" );

            #
            #  If the generated site older than the key or the bundle
            # then we need make no changes.
            #
            return 0 if ( ( $bundle < $site ) && ( $key < $site ) );
        }
        else
        {

            #
            #  If the generated site config file was
            # older than the generated file.
            #
            return 0 if ( $key < $site );
        }
    }

    my $bundle = "";
    if ( -e $CONFIG{ 'prefix' } . "/$domain/config/ssl.bundle" )
    {
        $bundle =
          "SSLCertificateChainFile $CONFIG{'prefix'}/$domain/config/ssl.bundle";
    }

    #
    #  Now we have all the details we need.
    #
    open( CONFIG, ">", "/etc/apache2/sites-enabled/$domain.ssl" ) or
      die "failed to write apache configuration file - $!";
    print CONFIG <<EOF;

####
##
#
# DO NOT EDIT THIS FILE - CHANGES WILL BE OVERWRITTEN
#
#  This file is automatically generated.
#
#  http://symbiosis.bytemark.co.uk/docs/ch-ssl-hosting.html
#
##
###


NameVirtualHost $ip:443

<VirtualHost $ip:443>

        SSLEngine On
        SSLCertificateFile $CONFIG{'prefix'}/$domain/config/ssl.key
        $bundle
        SSLOptions +StrictRequire


        #
        #  This is the directory people are redirected to
        # if their site is empty.
        #
        Alias /bytemark/ "/var/www/bytemark/"
        <Directory "/var/www/bytemark/">
                DirectoryIndex index.html
                AllowOverride None
        </Directory>

        #
        #  Allow users to override settings via .htaccess
        #
        <Directory "/srv">
                AllowOverride all
        </Directory>

        #
        #  And this makes that redirection happen.
        #
        <LocationMatch "^/+$">
                Options -Indexes
                ErrorDocument 403 /bytemark/
        </LocationMatch>

        #
        #  The document root
        #
        DocumentRoot     /srv/$domain/public/htdocs/

        #
        # General CGI Handling
        #
        ScriptAlias /cgi-bin/ $CONFIG{'prefix'}/$domain/public/cgi-bin/
        <Location /cgi-bin>
                Options +ExecCGI
        </Location>



        #
        #  We need to log the virtual hostname the incoming request was
        # made against, so that the cron-job in /etc/cron.daily may generate
        # statistics for each domain.
        #
        ErrorLog   /var/log/apache2/$domain.ssl.error.log
        CustomLog  /var/log/apache2/$domain.ssl.access.log combined
</VirtualHost>



NameVirtualHost $ip:80

<VirtualHost $ip:80>

        #
        #  This is the directory people are redirected to
        # if their site is empty.
        #
        Alias /bytemark/ "/var/www/bytemark/"
        <Directory "/var/www/bytemark/">
                DirectoryIndex index.html
                AllowOverride None
        </Directory>

        #
        #  Allow users to override settings via .htaccess
        #
        <Directory "/srv">
                AllowOverride all
        </Directory>

        #
        #  And this makes that redirection happen.
        #
        <LocationMatch "^/+$">
                Options -Indexes
                ErrorDocument 403 /bytemark/
        </LocationMatch>

        #
        #  The document root
        #
        DocumentRoot     /srv/$domain/public/htdocs/

        #
        # General CGI Handling
        #
        ScriptAlias /cgi-bin/ $CONFIG{'prefix'}/$domain/public/cgi-bin/
        <Location /cgi-bin>
                Options +ExecCGI
        </Location>



        #
        #  We need to log the virtual hostname the incoming request was
        # made against, so that the cron-job in /etc/cron.daily may generate
        # statistics for each domain.
        #
        ErrorLog   /var/log/apache2/$domain.error.log
        CustomLog  /var/log/apache2/$domain.access.log combined
</VirtualHost>


EOF
    close(CONFIG);


    #
    #  Return 1 - we appear to have found a non-configured host which
    # is ripe for SSL use.
    #
    return 1;
}



=begin doc

  Find the hostname & IP address of this host.

=end doc

=cut



sub findHostDetails
{

    #
    #   Find IP
    #
    my $ip = `/sbin/ifconfig eth0 | grep 'inet addr'`;
    if ( $ip =~ /addr:([^ ]*) / )
    {
        $ip = $1;
    }
    return ($ip);

}


=begin doc

Return the creation date of the specified file, which is expressed
in seconds past the epoch.

=end doc

=cut

sub createdTime
{
    my ($file) = (@_);


    if ( !-e $file )
    {
        print "WARNING: Failing to stat $file\n";
    }

    my ( $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
         $size, $atime, $mtime, $ctime, $blksize, $blocks
       ) = stat($file);


    $CONFIG{ 'verbose' } && print "File $file ctime:$ctime\n";
    return ($ctime);
}
