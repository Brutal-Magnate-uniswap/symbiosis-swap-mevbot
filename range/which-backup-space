#!/usr/bin/perl -w

=head1 NAME

which-backup-space -- determine which backup space is to be used.

=cut

=head1 SYNOPSIS

  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show debugging information.

=cut


=head1 ABOUT

This script just checks which backup space is allocated to an individual IP.

=cut

=head1 BUGS

Not IPv6 compatible.

=cut

=head1 AUTHOR

 Patrick J. Cherry <patrick@bytemark.co.uk>

=cut

#
#  Good practise.
#
use strict;
use warnings;


#
#  Modules we require
#
use Getopt::Long;
use Pod::Usage;
use Net::DNS;

#
#  Configuration variables
#
my %CONFIG;


#
#  Parse the command line.
#
parseCommandLineArguments();

#
#  Find the (primary) IP address of the system.
#
my $ip = shift;

if ( !defined( $ip ) )
{
    $ip = findHostDetails();
}

#
#  We only cope with IPv4 addresses
#
if ( $ip =~ /:/ )
{
    $CONFIG{ 'verbose' } && print "$ip looks like IPv6\n";
    exit 1;
}

foreach my $answer ( doDnsLookup( $ip ) )
{
  print $answer."\n";
}

exit 0;


sub parseCommandLineArguments
{
    my $HELP    = 0;
    my $MANUAL  = 0;

    if ( !GetOptions( "verbose", \$CONFIG{ 'verbose' },
                     "manual",       \$MANUAL,
                     "help",         \$HELP,
                    ) )
    {
        exit;
    }

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2, -noperldoc ) if $MANUAL;
}



=begin doc

  Find the hostname & IP address of this host.

=end doc

=cut



sub findHostDetails
{

    #
    #   Find IP
    #
    my $ip = `/sbin/ifconfig eth0 | grep 'inet addr'`;
    if ( $ip =~ /addr:([^ ]*) / )
    {
        $ip = $1;
    }

    #
    #  What did we find?
    #
    $CONFIG{ 'verbose' } && print "IP address is $ip\n";

    #
    #  Return it
    #
    return ($ip);

}

=being doc

  Do the DNS lookup

=end doc

=cut

sub doDnsLookup
{

  my $ip = $_[0];
  my $dnsr = join(".",reverse(split(/\./,$ip))).".backup-reverse.bytemark.co.uk";

  $CONFIG{ 'verbose' } && print "Looking up TXT record for $dnsr\n";

  # New DNS resolver querying Bytemark nameservers directly.  
  my $res = Net::DNS::Resolver->new(
    nameservers => [qw(a.ns.bytemark.co.uk b.ns.bytemark.co.uk c.ns.bytemark.co.uk)]
  );

  my $answers = $res->query($dnsr,"TXT");

  # Make sure we get an answer.
  if (!$answers) {
    $CONFIG{ 'verbose' } && print "No records found.\n";
    exit 2;
  }

  my @results;

  foreach my $rr ( $answers->answer )
  {
    if ($rr->type eq "TXT") {
      push(@results, $rr->txtdata)
    } else {
      $CONFIG{ 'verbose' } && print "Unexpected record type '".$rr->type."' received.\n";
    }
  }
  # The DNS lookup might return more than one record, in which case we sort them
  # alphabetically, since the order may well be random.

  return (sort(@results));
}

